using Content.Client.UserInterface.Controls;
using Content.Shared.Administration;
using Content.Shared.Security;
using Content.Shared.StationRecords;
using Content.Shared._CD.Records;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using System.Linq;
using System.Numerics;
using Content.Shared.Access.Systems;
using Content.Shared.CriminalRecords;
using Content.Shared.StatusIcon;
using Robust.Client.GameObjects;
using Robust.Client.Player;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;

namespace Content.Client._CD.Records.UI;

[GenerateTypedNameReferences]
public sealed partial class CharacterRecordViewer : FancyWindow
{
    [Dependency] private readonly IPlayerManager _player = default!;
    [Dependency] private readonly IPrototypeManager _proto = default!;
    [Dependency] private readonly IEntityManager _ent = default!;
    private readonly SpriteSystem _spriteSystem;
    private readonly AccessReaderSystem _accessReader;

    public readonly EntityUid Console;

    public struct CharacterListMetadata
    {
        public uint CharacterRecordKey;
        public uint? StationRecordKey;
    }

    public static readonly Color BackgroundColor = Color.FromHex("#25252a"); // Dark grey
    public static readonly Color ContentPanelColor = Color.FromHex("#1a1a1a"); // Darker grey for content areas
    public static readonly Color BorderColor = Color.FromHex("#404040"); // Light grey border
    public static readonly Color ErrorColor = Color.FromHex("#ff0000"); // Red for validation errors

    public event Action<CharacterListMetadata?>? OnListingItemSelected;
    public event Action<StationRecordFilterType, string?>? OnFiltersChanged;
    public Action<SecurityStatus>? OnStatusFilterPressed;
    public Action<CriminalRecord, bool, bool>? OnHistoryUpdated;
    public Action? OnHistoryClosed;

    private bool _isPopulating;
    private StationRecordFilterType _filterType;
    private SecurityStatus _currentSecurityStatusFilter;

    private RecordConsoleType? _type;

    private readonly RecordEntryViewPopup _entryView = new();
    private List<PlayerProvidedCharacterRecords.RecordEntry>? _entries;

    private DialogWindow? _wantedReasonDialog;

    /// <summary>
    /// The key to the record of the currently selected item in the listing.
    /// </summary>
    private uint? _selectedListingKey;

    /// <summary>
    /// The key to the record that is currently visible.
    /// </summary>
    /// <remarks>
    /// This may differ from <see cref="_selectedListingKey"/> because this contents has not been updated yet to reflect the new selection.
    /// </remarks>
    private uint? _openRecordKey;

    private CriminalRecord? _selectedCriminalRecord;
    private bool _access;

    public event Action<SecurityStatus, string?>? OnSetSecurityStatus;

    public uint? SecurityWantedStatusMaxLength;

    public CharacterRecordViewer(EntityUid console)
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        _spriteSystem = _ent.System<SpriteSystem>();
        _accessReader = _ent.System<AccessReaderSystem>();

        Console = console;

        // There is no reason why we can't just steal the StationRecordFilter class.
        // If wizden adds a new kind of filtering we want to replicate it here.
        foreach (var item in Enum.GetValues<StationRecordFilterType>())
        {
            RecordFilterType.AddItem(GetTypeFilterLocals(item), (int)item);
        }

        // Again, if wizden changes something about Criminal Records, we want to replicate the
        // functionality here.
        foreach (var status in Enum.GetValues<SecurityStatus>())
        {
            var name = Loc.GetString($"criminal-records-status-{status.ToString().ToLower()}");
            StatusOptionButton.AddItem(name, (int)status);
            SecurityStatusFilter.AddItem(GetCrewListFilterLocals(status), (int)status);
        }

        CharacterListing.OnItemSelected += _ =>
        {
            if (!CharacterListing.GetSelected().Any())
                return;
            var selected = CharacterListing.GetSelected().First();
            var meta = (CharacterListMetadata)selected.Metadata!;
            _selectedListingKey = meta.CharacterRecordKey;
            if (!_isPopulating)
                OnListingItemSelected?.Invoke(meta);
        };

        CharacterListing.OnItemDeselected += _ =>
        {
            // When we populate the records, we clear the contents of the listing.
            // This could cause a deselection but we don't want to really deselect because it would
            // interrupt what the player is doing.
            if (!_isPopulating)
                OnListingItemSelected?.Invoke(null);
            _selectedListingKey = null;
        };

        RecordFilters.OnPressed += _ =>
        {
            OnFiltersChanged?.Invoke(_filterType, RecordFiltersValue.Text);
        };

        RecordFiltersReset.OnPressed += _ =>
        {
            OnFiltersChanged?.Invoke(StationRecordFilterType.Name, null);
            RecordFiltersValue.Clear();
        };

        RecordFiltersValue.OnTextEntered += text =>
        {
            OnFiltersChanged?.Invoke(_filterType, text.Text);
        };

        RecordFiltersValue.OnTextEntered += text =>
        {
            OnFiltersChanged?.Invoke(_filterType, text.Text);
        };

        RecordFilterType.OnItemSelected += eventArgs =>
        {
            var type = (StationRecordFilterType)eventArgs.Id;
            _filterType = type;
            RecordFilterType.SelectId(eventArgs.Id);
        };

        //Select Status to filter crew
        SecurityStatusFilter.OnItemSelected += eventArgs =>
        {
            var type = (SecurityStatus)eventArgs.Id;

            if (_currentSecurityStatusFilter != type)
            {
                _currentSecurityStatusFilter = type;
                OnStatusFilterPressed?.Invoke(type);
            }
        };

        RecordEntryViewButton.OnPressed += _ =>
        {
            if (_entries == null || !RecordEntryList.GetSelected().Any())
                return;
            var idx = RecordEntryList.IndexOf(RecordEntryList.GetSelected().First());
            _entryView.SetContents(_entries[idx]);
            _entryView.Open();
        };

        StatusOptionButton.OnItemSelected += args =>
        {
            var status = (SecurityStatus)args.Id;
            // This should reflect SetStatus in CriminalRecordsConsoleWindow.xaml.cs
            if (status == SecurityStatus.Wanted || status == SecurityStatus.Suspected
                                                // Harmony additional statuses
                                                || status == SecurityStatus.Monitor || status == SecurityStatus.Search)
                SetStatusWithReason(status);
            else
                OnSetSecurityStatus?.Invoke(status, null);
        };

        RecordContainerCriminalHistoryButton.OnPressed += _ =>
        {
            if (_selectedCriminalRecord is { } record)
                OnHistoryUpdated?.Invoke(record, _access, true);
        };

        OnClose += () => _entryView.Close();

        // Admin console entry type selector
        RecordEntryViewType.AddItem(Loc.GetString("department-Security"));
        RecordEntryViewType.AddItem(Loc.GetString("department-Medical"));
        RecordEntryViewType.AddItem(Loc.GetString("humanoid-profile-editor-cd-records-employment"));
        RecordEntryViewType.OnItemSelected += args =>
        {
            if (args.Id == RecordEntryViewType.SelectedId)
                return;
            RecordEntryViewType.SelectId(args.Id);
            // This is a hack to get the server to send us another packet with the new entries
            OnFiltersChanged?.Invoke(_filterType, RecordFiltersValue.Text);
        };
    }

    // If we are using wizden's class we might as well use their localization.
    private string GetTypeFilterLocals(StationRecordFilterType type)
    {
        return Loc.GetString($"general-station-record-{type.ToString().ToLower()}-filter");
    }

    /// <summary>
    /// Select the record in the listing for the given key.
    /// </summary>
    /// <param name="key">The index of the record in the dictionary</param>
    private void SelectRecordKey(uint? key)
    {
        if (_selectedListingKey == key)
            return;
        _selectedListingKey = key;

        _isPopulating = true;

        CharacterListing.ClearSelected();

        // I wish there was a better way of doing this
        if (key != null)
        {
            foreach (var item in CharacterListing)
            {
                if (((CharacterListMetadata)item.Metadata!).CharacterRecordKey == key)
                {
                    item.Selected = true;
                    break;
                }
            }
        }

        _isPopulating = false;
    }

    private bool CharacterListNeedsRepopulating(
        IReadOnlyDictionary<uint, CharacterRecordConsoleState.CharacterInfo> newKeys)
    {
        var newCount = newKeys.Count;
        if (newCount != CharacterListing.Count)
            return true;

        // Given that there is the same number of keys in the dictionary as in items in the listing, they are not equal
        // if and only if there exists a key in the listing that is not in the dictionary
        foreach (var item in CharacterListing)
        {
            var key = ((CharacterListMetadata)item.Metadata!).CharacterRecordKey;
            if (!newKeys.ContainsKey(key))
            {
                return true;
            }
        }

        return false;
    }

    public void UpdateState(CharacterRecordConsoleState state)
    {
        _access = _player.LocalSession?.AttachedEntity is { } player
                  && _accessReader.IsAllowed(player, Console);

        #region Visibility

        RecordEntryViewType.Visible = false;
        _type = state.ConsoleType;

        // Disable listing if we don't have one selected
        if (state.CharacterList == null)
        {
            CharacterListingStatus.Visible = true;
            CharacterListing.Visible = false;
            CharacterListingStatus.Text = Loc.GetString("cd-record-viewer-empty-state");
            RecordContainer.Visible = false;
            RecordContainerStatus.Visible = false;
            return;
        }

        CharacterListingStatus.Visible = false;
        CharacterListing.Visible = true;

        SecurityStatusFilter.SelectId((int)_currentSecurityStatusFilter);
        SecurityStatusFilter.Visible = false;

        // Enable extended filtering only for admin and security consoles
        switch (_type)
        {
            case RecordConsoleType.Employment:
                RecordFilterType.Visible = false;
                RecordFilterType.SelectId((int)StationRecordFilterType.Name);

                Title = Loc.GetString("cd-character-records-viewer-title-employ");
                break;
            case RecordConsoleType.Medical:
                RecordFilterType.Visible = false;
                RecordFilterType.SelectId((int)StationRecordFilterType.Name);

                Title = Loc.GetString("cd-character-records-viewer-title-med");
                break;
            case RecordConsoleType.Security:
                RecordFilterType.Visible = true;
                SecurityStatusFilter.Visible = true;

                Title = Loc.GetString("cd-character-records-viewer-title-sec");
                break;
            case RecordConsoleType.Admin:
                RecordFilterType.Visible = true;
                Title = "Admin records console";
                RecordEntryViewType.Visible = true;

                break;
        }

        #endregion

        #region PopulateListing

        if (state.Filter != null)
        {
            RecordFiltersValue.SetText(state.Filter.Value);
            RecordFilterType.SelectId((int)state.Filter.Type);
        }

        if (CharacterListNeedsRepopulating(state.CharacterList))
        {
            _isPopulating = true;

            CharacterListing.Clear();

            // Add the records to the listing in a sorted order. There is probably are faster way of doing this, but
            // this is not really a hot code path.
            state.CharacterList
                // The items in this tuple are as follows: (name of character, CharacterListMetadata)
                .Select(r
                    => (CharacterName: r.Value.CharacterDisplayName,
                        new CharacterListMetadata()
                            { CharacterRecordKey = r.Key, StationRecordKey = r.Value.StationRecordKey }))
                .OrderBy(r => r.Item1)
                .ToList()
                .ForEach(r => CharacterListing.AddItem(r.Item1, metadata: r.Item2));

            _isPopulating = false;
        }

        SelectRecordKey(state.SelectedIndex);

        #endregion

        #region FillRecordContainer

        // Enable container if we have a record selected
        if (state.SelectedRecord == null)
        {
            RecordContainerStatus.Visible = true;
            RecordContainer.Visible = false;
            return;
        }

        RecordContainerStatus.Visible = false;
        RecordContainer.Visible = true;

        _openRecordKey = state.SelectedIndex;

        var record = state.SelectedRecord!;
        var cr = record.PRecords;

        // Basic info
        RecordContainerName.Text = record.Name;
        RecordContainerAge.Text = record.Age.ToString();
        RecordContainerJob.Text = record.JobTitle;
        if (_proto.TryIndex<JobIconPrototype>(record.JobIcon, out var proto))
        {
            RecordContainerJobIcon.Texture = _spriteSystem.Frame0(proto.Icon);
        }

        RecordContainerGender.Text = record.Gender.ToString();
        RecordContainerSpecies.Text = record.Species;
        RecordContainerHeight.Text = cr.Height + " " + UnitConversion.GetImperialDisplayLength(cr.Height);
        RecordContainerWeight.Text = cr.Weight + " " + UnitConversion.GetImperialDisplayMass(cr.Weight);
        RecordContainerContactName.SetValue(cr.EmergencyContactName);

        RecordContainerEmployment.Visible = false;
        RecordContainerMedical.Visible = false;
        RecordContainerSecurity.Visible = false;

        switch (_type)
        {
            case RecordConsoleType.Employment:
                SetEntries(cr.EmploymentEntries);
                UpdateRecordBoxEmployment(record);
                break;
            case RecordConsoleType.Medical:
                SetEntries(cr.MedicalEntries);
                UpdateRecordBoxMedical(record);
                break;
            case RecordConsoleType.Security:
                SetEntries(cr.SecurityEntries);
                UpdateRecordBoxSecurity(record, state.SelectedCriminalRecord);
                break;
            case RecordConsoleType.Admin:
                UpdateRecordBoxEmployment(record);
                UpdateRecordBoxMedical(record);
                UpdateRecordBoxSecurity(record, state.SelectedCriminalRecord);
                switch ((RecordConsoleType)RecordEntryViewType.SelectedId)
                {
                    case RecordConsoleType.Employment:
                        SetEntries(cr.EmploymentEntries, true);
                        break;
                    case RecordConsoleType.Medical:
                        SetEntries(cr.MedicalEntries, true);
                        break;
                    case RecordConsoleType.Security:
                        SetEntries(cr.SecurityEntries, true);
                        break;
                }
                break;
        }

        #endregion

    }

    private void SetEntries(List<PlayerProvidedCharacterRecords.RecordEntry> entries, bool addIndex = false)
    {
        _entries = entries;
        RecordEntryList.Clear();
        var i = 0;
        foreach (var entry in entries)
        {
            RecordEntryList.AddItem(addIndex ? $"({i.ToString()}) " + entry.Title : entry.Title);
            ++i;
        }
    }

    private void UpdateRecordBoxEmployment(FullCharacterRecords record)
    {
        RecordContainerEmployment.Visible = true;
        RecordContainerWorkAuth.Text = record.PRecords.HasWorkAuthorization ? "yes" : "no";
    }

    private void UpdateRecordBoxMedical(FullCharacterRecords record)
    {
        RecordContainerMedical.Visible = true;
        var cr = record.PRecords;
        RecordContainerMedical.Visible = true;
        RecordContainerAllergies.SetValue(cr.Allergies);
        RecordContainerDrugAllergies.SetValue(cr.DrugAllergies);
        RecordContainerPostmortem.SetValue(cr.PostmortemInstructions);
        RecordContainerSex.Text = record.Sex.ToString();
    }

    private void UpdateRecordBoxSecurity(FullCharacterRecords record, CriminalRecord? criminal)
    {
        RecordContainerSecurity.Visible = true;
        RecordContainerIdentFeatures.SetValue(record.PRecords.IdentifyingFeatures);
        RecordContainerFingerprint.Text = record.Fingerprint ?? Loc.GetString("cd-character-records-viewer-unknown");
        RecordContainerDNA.Text = record.DNA ?? Loc.GetString("cd-character-records-viewer-unknown");

        if (criminal != null)
        {
            _selectedCriminalRecord = criminal;

            var stat = criminal.Status;
            var reason = criminal.Reason;

            // Criminal status reason text
            StatusOptionButton.Select((int)stat);
            RecordContainerWantedReason.SetMessage(reason ?? "");
            RecordContainerWantedReasonContainer.Visible = reason != null;

            // Update any open history windows.
            OnHistoryUpdated?.Invoke(criminal, _access, false);
        }
        else
        {
            // Close any open history windows.
            OnHistoryClosed?.Invoke();
        }

        RecordContainerWantedIcon.SetFromSpriteSpecifier(GetWantedStatusIcon(criminal?.Status ?? SecurityStatus.None));
        RecordContainerWantedIcon.DisplayRect.TextureScale = new Vector2(3f, 3f);
    }

    // This is copied almost verbatim from CriminalRecordsConsoleWindow.xaml.cs
    private void SetStatusWithReason(SecurityStatus status)
    {
        if (_wantedReasonDialog != null)
        {
            _wantedReasonDialog.MoveToFront();
            return;
        }

        const string field = "reason";
        var title = Loc.GetString("criminal-records-status-" + status.ToString().ToLower());
        var placeholder = Loc.GetString("cd-character-records-viewer-setwanted-placeholder");
        var prompt = Loc.GetString("criminal-records-console-reason");
        var entry = new QuickDialogEntry(field, QuickDialogEntryType.LongText, prompt, placeholder);
        var entries = new List<QuickDialogEntry>() { entry };
        _wantedReasonDialog = new DialogWindow(title, entries);

        _wantedReasonDialog.OnConfirmed += responses =>
        {
            var reason = responses[field];
            if (reason.Length < 1 || reason.Length > SecurityWantedStatusMaxLength)
                return;

            OnSetSecurityStatus?.Invoke(status, reason);
        };

        _wantedReasonDialog.OnClose += () => { _wantedReasonDialog = null; };
    }

    public bool IsSecurity()
    {
        return _type == RecordConsoleType.Security || _type == RecordConsoleType.Admin;
    }

    public void SetSecurityStatusEnabled(bool setting)
    {
        for (var i = 0; i < StatusOptionButton.ItemCount; ++i)
        {
            StatusOptionButton.SetItemDisabled(i, !setting);
        }
    }

    private SpriteSpecifier GetWantedStatusIcon(SecurityStatus status)
    {
        if (status == SecurityStatus.None)
            return new SpriteSpecifier.Rsi(new ResPath("Interface/Misc/job_icons.rsi"), "Unknown");

        return new SpriteSpecifier.Rsi(
            new ResPath(status switch
            {
                SecurityStatus.Monitor => "_Harmony/Interface/Misc/security_icons.rsi",
                SecurityStatus.Search => "_Harmony/Interface/Misc/security_icons.rsi",
                _ => "Interface/Misc/security_icons.rsi",
            }),
            status switch
            {
                SecurityStatus.Monitor => "hud_monitor",
                SecurityStatus.Search => "hud_search",
                SecurityStatus.Paroled => "hud_paroled",
                SecurityStatus.Wanted => "hud_wanted",
                SecurityStatus.Detained => "hud_incarcerated",
                SecurityStatus.Discharged => "hud_discharged",
                SecurityStatus.Suspected => "hud_suspected",
                _ => "SecurityIconNone",
            }
        );
    }

    private string GetCrewListFilterLocals(SecurityStatus type)
    {
        string result;

        // If "NONE" override to "show all"
        if (type == SecurityStatus.None)
        {
            result = Loc.GetString("criminal-records-console-show-all");
        }
        else
        {
            result = Loc.GetString($"criminal-records-status-{type.ToString().ToLower()}");
        }

        return result;
    }
}
